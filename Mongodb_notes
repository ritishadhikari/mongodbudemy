Mongodb Databases does not contain any schema. 

1. show dbs : Display all the available databases.
2. use shop : Switching to a particular database
3. db.products.insertone({name:'A Book',price:300}) : Inserting a record to the collection products.
4. db.products.find() : To explore the collections.
5. db.products.find().pretty() : To explore the collections in a better looking manner.
 
A collection is equivalent to a table in Mongodb. 

Without creating a record in a database, the database actually don't get created even we are using that database.

Mongodb stores the user input json data into bson data which is much more efficient to use.

It is not necessary that the _id will be generated directly. User can also input the _id manually. The only condition is that the ids in each documents needs to be distinct.

Create -> insertOne(data,options); insertMany(data,options)
Read -> find(filter, options); findOne(filter, options)
Update -> updateOne(filter, data, options); updateMany(filter, data, options); replaceOne(filter, data, options)
Delete -> deleteOne(filter, options); deleteMany(filter, options)

6. db.fightData.deleteOne({"departureAirport": "MUC"}) : Delete a Document from the collection. 
7. db.fightData.updateOne({"departureAirport":"TXL"}, {$set:{"marker":"delete"}}) : Update a Document by entering a new information. Look at the $set command.
8. db.fightData.updateMany({}, {$set:{"marker":"todelete"}}) : Update all the Documents in the collection  by entering a new information.
9. db.fightData.deleteMany({"marker":"todelete"}) : Delete all the document which has marker as delete.
10.db.fightData.insertMany([{"departureAirport":"MUC","arrivalAirport":"SFO","aircraft":"Airport A380","distance":12000,"intercontinental":true},
{"departureAirport":"TXL","arrivalAirport":"LHR","_id":"ritz0607"}]) : Insert Multiple Document in a Collection.
11. db.fightData.find({departureAirport:"TXL"}).pretty() : Find a Document with departureAirport as TXL
12. db.fightData.find({distance:{$gt:10000}}).pretty(): Find a Document with distance greater than 10000

Incase we are using Update command inplace of Updateone or Updatemany, then all the objects are overwritten which is not the case for the later two. Hence we use set command with updateone 
and updatemany.

For replacing more than one object in a document we can also us the replaceone command.
13. db.passengers.find().toArray() : This command shows all the documents unlike Pretty which shows only the first 20 documents.
14. db.passengers.find({},{_id:0,name:1,age:0}): Project only the name from each document. Here _id:0 is mandatory while age:0 is optional.
15. db.passengers.find({"age":35},{"name":1, _id:0}).pretty() : Equivalent to select name from passengers where age=35.

Mongodb support embedded documents. Upto 100 levels of Nesting in each document and maximum of 16 mb per document.
16. db.passengers.findOne({name:"Maria Jones"})["hobbies"] : Select hobbies from passengers where name = 'Maria Jones'

17. db.patientdata.find({"history.0.treatment":"acidity"}) : Command to find for a specific document when we are searching for an embedding document.
18. db.patientdate.drop() : Drop a Collection.
19. db.dropDatabase() : Command to drop a Database after using the Database.

Data Types in Mongodb : 
a. Text : 16 MB per Document
b. Booleans : True/ False
c. Integers : Int32, Int64
d. NumberDecimals : High Precision Floating Point values.
e. objectId : Unique ID containing a temporal component which are successive in order as per the document creation.
f. ISODate : Date Type
g. Timestamp : ex : 11421532
h. Embedded Documents
i. Arrrays : List of strings, Numbers etc.

18. db.stats() : Provides the statistics of the Database.
19. db.numbers.insertOne({a:NumberInt(1)}) : Initialising object a with Mongobd initialized number 1. Also can be included is NUmberLong and NumberDecimal.
 

EMbeddings are necessary when there is a strong one-one document.

We may carry on with embeddings or we may create separate collections and then merge the documents based on some objects.

For One to Many or Many to Many, we may consider referencing as so to mitigate the edit and modifications for individual collections or documents.

20. db.books.aggregate([{$lookup:{from :"authors", localField:"author.auth_id", foreignField: "_id",as:"creators"}}]).pretty() : Use lookup for joining books collection with author collection with alias
name as creators.

We can define rules to validate inserts and update before writing to the database. We need to chose validation level and action based on our application requirements. Lecture 52 and 53. 

21.db.createCollection("post",
{validator:{
   $jsonSchema: {bsonType: "object",
              required : ["title","text","creator", "comment"],
              properties:{
                title:{
                  bsonType:'string',
                  description:"String Field is Required"},
                  text:{
                    bsonType:'string',
                    description:"String Field is Required"
                  },
                  creator:{
                    bsonType:'objectId',
                    description:"ObjectId is Required"
                  },
                  comment:{
                    bsonType:'array',
                    description:"Array field is Required",
                    items :{
                      bsonType:'object',
                      required : ['text','author'],
                      properties: {
                        text:{
                          bsonType:'string',
                          description:"string is required"
                        },
                        author:{
                          bsonType:'objectId',
                          description:"objectId is required"
                        }

                      }
                    }

              }}}}}); - Schema Validation Code. Error will be thrown if this is technique is not adhered to.

22. db.runCommand({
  collMod: 'posts',
  validator: {
    $jsonSchema: {
      bsonType: 'object',
      required: ['title', 'text', 'creator', 'comments'],
      properties: {
        title: {
          bsonType: 'string',
          description: 'must be a string and is required'
        },
        text: {
          bsonType: 'string',
          description: 'must be a string and is required'
        },
        creator: {
          bsonType: 'objectId',
          description: 'must be an objectid and is required'
        },
        comments: {
          bsonType: 'array',
          description: 'must be an array and is required',
          items: {
            bsonType: 'object',
            required: ['text', 'author'],
            properties: {
              text: {
                bsonType: 'string',
                description: 'must be a string and is required'
              },
              author: {
                bsonType: 'objectId',
                description: 'must be an objectid and is required'
              }
            }
          }
        }
      }
    }
  },
  validationAction: 'warn'
}); : To set up a validator with a warning message. 

23. sudo mongod --dbpath ~/mongodb/mongodbudemy/db : To set up a new Database storage location
24. sudo mongod --dbpath ~/mongodb/mongodbudemy/db sudo --logpath ~/mongodb/mongodbudemy/logs   : To set up a new Database storage location and also Create a Log path
25. sudo mongo -fork --logpath ~/mongodb/mongodbudemy/logs : To continue with the linux terminal even after starting a child mongodb instance.
26. sudo mongod -f configuration_file_path: To set up the configuration file parameters like logs and storage by just passing the configuration file list.
27. db.collection_name.help: Provides the help menu on the collection selected.
28. db.hobbies.insertMany([{_id:'yoga', name:'Yoga'},{_id:"cooking", name: "Cooking"}, {_id:"hiking", name:"Hiking"}], {ordered:false}) : Even if an ID exist before a non existant ID, Mongo db will 
add the non existant id into its database while throwing the duplicate id error for the duplicate ids. 
29. db.persons.insertOne({name:'rohit', age:26},{writeConcern:{w:1}}) : with w:0 as writeConcern, the data is not stored into the memory although it is stored in the database. Hence we get an 
acknowldgement as False. with w:1 as thr writeConcern, the data is both stored in the database as well as saved in the memory.
30. db.persons.insertOne({name:'antik', age:15},{writeConcern:{w:1,j:true}}) : Adding the data also in the journal so that the data is stored in the database without fail. It provides more security.
31. db.persons.insertOne({name:'antik', age:15},{writeConcern:{w:1,j:true,wtimeout:200}})  : Adding the data with a time out option. Incase the data is not added in that max milisecond, then the fail 
will happen and so that user don't have to wait unnecessarily and can upload the data once again. 
32. mongoimport tv-shows.json -d movie_data -c movies --jsonArray --drop : Importing the tv-shows.json file into the movies collection of movie_data database. It is indicating that it 
contains json arrays and drop any collection with the name movies before freshly creating and then adding the json file into the mentioned database. This command is written in the shell. 
33. db.movies.find({"schedule.days":"Sunday"}).pretty() : To find the schedule days which are SUndays. The schedule.days can consists of other days too.
34. db.movies.find({"schedule.days":["Sunday"]}).pretty() : To find the schedule days which are Sundays. The schedule.days will consist of only a sunday.
35. db.movies.find({"schedule.days":{$nin: ["Monday","Tuesday","Sunday"]}}).pretty() : To find the schedule days which are not in the given days.
36. db.movies.find({"schedule.days":{$in: ["Monday","Tuesday","Sunday"]}}).pretty() : To find the schedule days which are in that given day.
37. db.movies.find({$or:[{"rating.average":{$gt:9}},{"rating.average":{$lt:4}}]}).count() : Gives the count of records where average rating is either greater than 9 or is less than 4.
38. db.movies.find({$nor:[{"rating.average":{$gt:3}},{"rating.average":{$lt:9}}]}).count() : Gives the count of records where average rating is neither greater than 9 or is less than 4.
39. db.movies.find({$and:[{"rating.average":"$gt:3"},{"rating.average":{$lt:9}}]}).count() : Gives the count of records where average rating is between 3 and 9. 
40. db.movies.find({"rating.average":{$not:{$eq:8}}}).count() : Gives the rating of the movies whose average rating is not equal to 8. Also similar command is : 
db.movies.find({"rating.average":{$ne:8}}).count()
41. db.users.find({age:{$exists:true, $gt : 25}}).pretty() : Gives the documents where age as an object exists and where age is greater than 25
42. db.users.find({age:{$exists:true, $gt:25, $ne:null}}).pretty() : Gives the documents where age as an object exists but age should not be null and age should exist.
43. db.users.find({$and:[{age:{$exists:true}},{age:{$gt:25}},{age:{$ne:null}}]}).pretty() : Gives the Documents where age exists and age is greater than 25 and where age is not null.
44. db.users.find({phone:{$type:["string","double"]}}).pretty() : Gives the Documents where the data type of the phone number is either a string or an integer number(double).
45. db.movies.find({summary:{$regex:/musical/}}).count() : Gives the count of records where the summary object contains a word - musical.
46. db.sales.find({$expr:{$gt:["$volume","$target"]}}).pretty() : Returns only those documents where volume field is greater than the target field.
47. db.users.find({hobbies:{$size:3}}).pretty() : Finds only those documents whish has hobbies as length 3. 
48. db.users.find({hobbies:{$all:["Sports","Cooking"]}}) : Searches for documents which has either Sports and Cooking as hobbies without the order.
49. db.users.find({Hobbies:{$elemMatch:{title:"Sports", frequency:{$gte:2}}}}).pretty() : Gives the results only for those Hobbies which has both title as Sports and frequency of greater than 
2 under the same object.
50. db.movie_data.find().next: Gives the next one document. It is a cursor with one document at a time. Initialize it with a vaiable and do .next on the variable.
51. db.movie_data.find().sort({"externals.tvrage":1,"network.id":-1}).pretty() : Sorts externals.tvrage in ascending and network.id in descending.
52. db.movies.find().sort({"externals.tvrage":1,"network.id":-1}).skip(2*10).limit(10).pretty() : Useful for pagination purpose where the first few values are skipped and only the next few values
are only displayed. Here in this example, the first 20 values are skipped and only the next 10 values are displayed signifuing it to be page no 3. 
53. db.movies.find({genres:"Drama"},{"genres.$":1}) : Dislay only the genres as Drama although the Genres may have different genres as well in that document like horror, etc.
54. db.movies.find({genres:"Drama"},{genres:{$elemMatch:{$eq:"Horror"}}}).pretty() : Display the genres which has mandatory Drama but also Horror as well separately.
55. db.movies.find({genres:"Drama"},{genres:{$slice:2}}).pretty() : To display the first two genres in the database which has Drama as a genre mandatorily.
56. db.movies.find({genres:"Drama"},{genres:{$slice:[1,3}}).pretty() : To display the first two genres by skipping the first genre in the database which has Drama as a genre mandatorily.
