Mongodb Databases does not contain any schema. 

1. show dbs : Display all the available databases.
2. use shop : Switching to a particular database
3. db.products.insertone({name:'A Book',price:300}) : Inserting a record to the collection products.
4. db.products.find() : To explore the collections.
5. db.products.find().pretty() : To explore the collections in a better looking manner.
 
A collection is equivalent to a table in Mongodb. 

Without creating a record in a database, the database actually don't get created even we are using that database.

Mongodb stores the user input json data into bson data which is much more efficient to use.

It is not necessary that the _id will be generated directly. User can also input the _id manually. The only condition is that the ids in each documents needs to be distinct.

Create -> insertOne(data,options); insertMany(data,options)
Read -> find(filter, options); findOne(filter, options)
Update -> updateOne(filter, data, options); updateMany(filter, data, options); replaceOne(filter, data, options)
Delete -> deleteOne(filter, options); deleteMany(filter, options)

6. db.fightData.deleteOne({"departureAirport": "MUC"}) : Delete a Document from the collection. 
7. db.fightData.updateOne({"departureAirport":"TXL"}, {$set:{"marker":"delete"}}) : Update a Document by entering a new information. Look at the $set command.
8. db.fightData.updateMany({}, {$set:{"marker":"todelete"}}) : Update all the Documents in the collection  by entering a new information.
9. db.fightData.deleteMany({"marker":"todelete"}) : Delete all the document which has marker as delete.
10.db.fightData.insertMany([{"departureAirport":"MUC","arrivalAirport":"SFO","aircraft":"Airport A380","distance":12000,"intercontinental":true},
{"departureAirport":"TXL","arrivalAirport":"LHR","_id":"ritz0607"}]) : Insert Multiple Document in a Collection.
11. db.fightData.find({departureAirport:"TXL"}).pretty() : Find a Document with departureAirport as TXL
12. db.fightData.find({distance:{$gt:10000}}).pretty(): Find a Document with distance greater than 10000

Incase we are using Update command inplace of Updateone or Updatemany, then all the objects are overwritten which is not the case for the later two. Hence we use set command with updateone 
and updatemany.

For replacing more than one object in a document we can also us the replaceone command.
13. db.passengers.find().toArray() : This command shows all the documents unlike Pretty which shows only the first 20 documents.
14. db.passengers.find({},{_id:0,name:1,age:0}): Project only the name from each document. Here _id:0 is mandatory while age:0 is optional.
15. db.passengers.find({"age":35},{"name":1, _id:0}).pretty() : Equivalent to select name from passengers where age=35.

Mongodb support embedded documents. Upto 100 levels of Nesting in each document and maximum of 16 mb per document.
16. db.passengers.findOne({name:"Maria Jones"})["hobbies"] : Select hobbies from passengers where name = 'Maria Jones'

17. db.patientdata.find({"history.0.treatment":"acidity"}) : Command to find for a specific document when we are searching for an embedding document.
18. db.patientdate.drop() : Drop a Collection.
19. db.dropDatabase() : Command to drop a Database after using the Database.

Data Types in Mongodb : 
a. Text : 16 MB per Document
b. Booleans : True/ False
c. Integers : Int32, Int64
d. NumberDecimals : High Precision Floating Point values.
e. objectId : Unique ID containing a temporal component which are successive in order as per the document creation.
f. ISODate : Date Type
g. Timestamp : ex : 11421532
h. Embedded Documents
i. Arrrays : List of strings, Numbers etc.

18. db.stats() : Provides the statistics of the Database.
19. db.numbers.insertOne({a:NumberInt(1)}) : Initialising object a with Mongobd initialized number 1. Also can be included is NUmberLong and NumberDecimal.
 

EMbeddings are necessary when there is a strong one-one document.

We may carry on with embeddings or we may create separate collections and then merge the documents based on some objects.

For One to Many or Many to Many, we may consider referencing as so to mitigate the edit and modifications for individual collections or documents.

20. db.books.aggregate([{$lookup:{from :"authors", localField:"author.auth_id", foreignField: "_id",as:"creators"}}]).pretty() : Use lookup for joining books collection with author collection with alias
name as creators.

We can define rules to validate inserts and update before writing to the database. We need to chose validation level and action based on our application requirements. Lecture 52 and 53. 

21.db.createCollection("post",
{validator:{
   $jsonSchema: {bsonType: "object",
              required : ["title","text","creator", "comment"],
              properties:{
                title:{
                  bsonType:'string',
                  description:"String Field is Required"},
                  text:{
                    bsonType:'string',
                    description:"String Field is Required"
                  },
                  creator:{
                    bsonType:'objectId',
                    description:"ObjectId is Required"
                  },
                  comment:{
                    bsonType:'array',
                    description:"Array field is Required",
                    items :{
                      bsonType:'object',
                      required : ['text','author'],
                      properties: {
                        text:{
                          bsonType:'string',
                          description:"string is required"
                        },
                        author:{
                          bsonType:'objectId',
                          description:"objectId is required"
                        }

                      }
                    }

              }}}}}); - Schema Validation Code. Error will be thrown if this is technique is not adhered to.

22. db.runCommand({
  collMod: 'posts',
  validator: {
    $jsonSchema: {
      bsonType: 'object',
      required: ['title', 'text', 'creator', 'comments'],
      properties: {
        title: {
          bsonType: 'string',
          description: 'must be a string and is required'
        },
        text: {
          bsonType: 'string',
          description: 'must be a string and is required'
        },
        creator: {
          bsonType: 'objectId',
          description: 'must be an objectid and is required'
        },
        comments: {
          bsonType: 'array',
          description: 'must be an array and is required',
          items: {
            bsonType: 'object',
            required: ['text', 'author'],
            properties: {
              text: {
                bsonType: 'string',
                description: 'must be a string and is required'
              },
              author: {
                bsonType: 'objectId',
                description: 'must be an objectid and is required'
              }
            }
          }
        }
      }
    }
  },
  validationAction: 'warn'
}); : To set up a validator with a warning message. 
