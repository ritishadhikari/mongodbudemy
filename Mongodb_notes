Mongodb Databases does not contain any schema. 

1. show dbs : Display all the available databases.
2. use shop : Switching to a particular database
3. db.products.insertone({name:'A Book',price:300}) : Inserting a record to the collection products.
4. db.products.find() : To explore the collections.
5. db.products.find().pretty() : To explore the collections in a better looking manner.
 
A collection is equivalent to a table in Mongodb. 

Without creating a record in a database, the database actually don't get created even we are using that database.

Mongodb stores the user input json data into bson data which is much more efficient to use.

It is not necessary that the _id will be generated directly. User can also input the _id manually. The only condition is that the ids in each documents needs to be distinct.

Create -> insertOne(data,options); insertMany(data,options)
Read -> find(filter, options); findOne(filter, options)
Update -> updateOne(filter, data, options); updateMany(filter, data, options); replaceOne(filter, data, options)
Delete -> deleteOne(filter, options); deleteMany(filter, options)

6. db.fightData.deleteOne({"departureAirport": "MUC"}) : Delete a Document from the collection. 
7. db.fightData.updateOne({"departureAirport":"TXL"}, {$set:{"marker":"delete"}}) : Update a Document by entering a new information. Look at the $set command.
8. db.fightData.updateMany({}, {$set:{"marker":"todelete"}}) : Update all the Documents in the collection  by entering a new information.
9. db.fightData.deleteMany({"marker":"todelete"}) : Delete all the document which has marker as delete.
10.db.fightData.insertMany([{"departureAirport":"MUC","arrivalAirport":"SFO","aircraft":"Airport A380","distance":12000,"intercontinental":true},
{"departureAirport":"TXL","arrivalAirport":"LHR","_id":"ritz0607"}]) : Insert Multiple Document in a Collection.
11. db.fightData.find({departureAirport:"TXL"}).pretty() : Find a Document with departureAirport as TXL
12. db.fightData.find({distance:{$gt:10000}}).pretty(): Find a Document with distance greater than 10000

Incase we are using Update command inplace of Updateone or Updatemany, then all the objects are overwritten which is not the case for the later two. Hence we use set command with updateone 
and updatemany.

For replacing more than one object in a document we can also us the replaceone command.
13. db.passengers.find().toArray() : This command shows all the documents unlike Pretty which shows only the first 20 documents.
14. db.passengers.find({},{_id:0,name:1,age:0}): Project only the name from each document. Here _id:0 is mandatory while age:0 is optional.
15. db.passengers.find({"age":35},{"name":1, _id:0}).pretty() : Equivalent to select name from passengers where age=35.

Mongodb support embedded documents. Upto 100 levels of Nesting in each document and maximum of 16 mb per document.
16. db.passengers.findOne({name:"Maria Jones"})["hobbies"] : Select hobbies from passengers where name = 'Maria Jones'

17. db.patientdata.find({"history.0.treatment":"acidity"}) : Command to find for a specific document when we are searching for an embedding document.
18. db.patientdate.drop() : Drop a Collection.
19. db.dropDatabase() : Command to drop a Database after using the Database.

Data Types in Mongodb : 
a. Text : 16 MB per Document
b. Booleans : True/ False
c. Integers : Int32, Int64
d. NumberDecimals : High Precision Floating Point values.
e. objectId : Unique ID containing a temporal component which are successive in order as per the document creation.
f. ISODate : Date Type
g. Timestamp : ex : 11421532
h. Embedded Documents
i. Arrrays : List of strings, Numbers etc.

18. db.stats() : Provides the statistics of the Database.
19. db.numbers.insertOne({a:NumberInt(1)}) : Initialising object a with Mongobd initialized number 1. Also can be included is NUmberLong and NumberDecimal.
 

EMbeddings are necessary when there is a strong one-one document.

We may carry on with embeddings or we may create separate collections and then merge the documents based on some objects.

For One to Many or Many to Many, we may consider referencing as so to mitigate the edit and modifications for individual collections or documents.

20. db.books.aggregate([{$lookup:{from :"authors", localField:"author.auth_id", foreignField: "_id",as:"creators"}}]).pretty() : Use lookup for joining books collection with author collection with alias
name as creators.

We can define rules to validate inserts and update before writing to the database. We need to chose validation level and action based on our application requirements. Lecture 52 and 53. 

21.db.createCollection("post",
{validator:{
   $jsonSchema: {bsonType: "object",
              required : ["title","text","creator", "comment"],
              properties:{
                title:{
                  bsonType:'string',
                  description:"String Field is Required"},
                  text:{
                    bsonType:'string',
                    description:"String Field is Required"
                  },
                  creator:{
                    bsonType:'objectId',
                    description:"ObjectId is Required"
                  },
                  comment:{
                    bsonType:'array',
                    description:"Array field is Required",
                    items :{
                      bsonType:'object',
                      required : ['text','author'],
                      properties: {
                        text:{
                          bsonType:'string',
                          description:"string is required"
                        },
                        author:{
                          bsonType:'objectId',
                          description:"objectId is required"
                        }

                      }
                    }

              }}}}}); - Schema Validation Code. Error will be thrown if this is technique is not adhered to.

22. db.runCommand({
  collMod: 'posts',
  validator: {
    $jsonSchema: {
      bsonType: 'object',
      required: ['title', 'text', 'creator', 'comments'],
      properties: {
        title: {
          bsonType: 'string',
          description: 'must be a string and is required'
        },
        text: {
          bsonType: 'string',
          description: 'must be a string and is required'
        },
        creator: {
          bsonType: 'objectId',
          description: 'must be an objectid and is required'
        },
        comments: {
          bsonType: 'array',
          description: 'must be an array and is required',
          items: {
            bsonType: 'object',
            required: ['text', 'author'],
            properties: {
              text: {
                bsonType: 'string',
                description: 'must be a string and is required'
              },
              author: {
                bsonType: 'objectId',
                description: 'must be an objectid and is required'
              }
            }
          }
        }
      }
    }
  },
  validationAction: 'warn'
}); : To set up a validator with a warning message. 

23. sudo mongod --dbpath ~/mongodb/mongodbudemy/db : To set up a new Database storage location
24. sudo mongod --dbpath ~/mongodb/mongodbudemy/db sudo --logpath ~/mongodb/mongodbudemy/logs   : To set up a new Database storage location and also Create a Log path
25. sudo mongo -fork --logpath ~/mongodb/mongodbudemy/logs : To continue with the linux terminal even after starting a child mongodb instance.
26. sudo mongod -f configuration_file_path: To set up the configuration file parameters like logs and storage by just passing the configuration file list.
27. db.collection_name.help: Provides the help menu on the collection selected.
28. db.hobbies.insertMany([{_id:'yoga', name:'Yoga'},{_id:"cooking", name: "Cooking"}, {_id:"hiking", name:"Hiking"}], {ordered:false}) : Even if an ID exist before a non existant ID, Mongo db will 
add the non existant id into its database while throwing the duplicate id error for the duplicate ids. 
29. db.persons.insertOne({name:'rohit', age:26},{writeConcern:{w:1}}) : with w:0 as writeConcern, the data is not stored into the memory although it is stored in the database. Hence we get an 
acknowldgement as False. with w:1 as thr writeConcern, the data is both stored in the database as well as saved in the memory.
30. db.persons.insertOne({name:'antik', age:15},{writeConcern:{w:1,j:true}}) : Adding the data also in the journal so that the data is stored in the database without fail. It provides more security.
31. db.persons.insertOne({name:'antik', age:15},{writeConcern:{w:1,j:true,wtimeout:200}})  : Adding the data with a time out option. Incase the data is not added in that max milisecond, then the fail 
will happen and so that user don't have to wait unnecessarily and can upload the data once again. 
32. mongoimport tv-shows.json -d movie_data -c movies --jsonArray --drop : Importing the tv-shows.json file into the movies collection of movie_data database. It is indicating that it 
contains json arrays and drop any collection with the name movies before freshly creating and then adding the json file into the mentioned database. This command is written in the shell. 

